name: 'Merge - Deployment'

on:
  push:
    branches: [ main ]

env:
  GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  AWS_REGION: ${{ vars.AWS_REGION }}
  AWS_ACCOUNT_ID: ${{ vars.AWS_ACCOUNT_ID }}
  AWS_ROLE_TO_ASSUME: ${{ vars.AWS_ROLE_TO_ASSUME }}
  STACK_NAME: ${{ vars.STACK_NAME || 'test-template' }}

jobs:
  terraform-apply:
    name: 'Terraform Apply'
    permissions:
      contents: read # for actions/checkout to fetch code
      id-token: write
      issues: write # needed to create issues
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        id: configure-aws-credentials
        uses: aws-actions/configure-aws-credentials@v4.1.0
        with:
          audience: sts.amazonaws.com
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: arn:aws:iam::${{ env.AWS_ACCOUNT_ID }}:role/${{ env.AWS_ROLE_TO_ASSUME }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.11.2"

      - name: Terraform Apply
        id: apply
        working-directory: ./terraform
        run: |
          # Fetch AWS Account ID
          ACCOUNT_ID=$(aws sts get-caller-identity --query 'Account' --output text)
          # Configure Terraform backend
          REPO_OWNER=${GITHUB_REPOSITORY_OWNER}
          REPO_NAME=${GITHUB_REPOSITORY}

          # Get parameters
          echo "Get *.tfvars from SSM parameter"
          aws ssm get-parameter \
            --name "/dcsummit25/cop401/terraform/tfvars" \
            --query "Parameter.Value" \
            --output "text" \
            --region $AWS_REGION >> terraform.tfvars

          # Run Terraform
          terraform init -backend-config="bucket=$ACCOUNT_ID-tf-state" -backend-config="key=state/$ACCOUNT_ID/$REPO_OWNER/$REPO_NAME/terraform.tfstate" -backend-config="region=$AWS_REGION" -backend-config="encrypt=true" -backend-config="use_lockfile=true"
          terraform plan -var-file="terraform.tfvars" -no-color -out=tfplan

          # Capture the apply output
          echo "::group::Terraform Apply"
          APPLY_OUTPUT=$(terraform apply -input=false -no-color -auto-approve tfplan 2>&1)
          APPLY_EXIT_CODE=$?
          echo "$APPLY_OUTPUT"
          echo "::endgroup::"

          # Save the output for summary
          echo "$APPLY_OUTPUT" > apply_output.txt

          # Extract resource counts
          RESOURCES_ADDED=$(echo "$APPLY_OUTPUT" | grep -o 'Apply complete! Resources: [0-9]* added' | grep -o '[0-9]*' || echo "0")
          RESOURCES_CHANGED=$(echo "$APPLY_OUTPUT" | grep -o '[0-9]* changed' | grep -o '[0-9]*' || echo "0")
          RESOURCES_DESTROYED=$(echo "$APPLY_OUTPUT" | grep -o '[0-9]* destroyed' | grep -o '[0-9]*' || echo "0")

          # Set outputs for later steps
          echo "resources_added=$RESOURCES_ADDED" >> $GITHUB_OUTPUT
          echo "resources_changed=$RESOURCES_CHANGED" >> $GITHUB_OUTPUT
          echo "resources_destroyed=$RESOURCES_DESTROYED" >> $GITHUB_OUTPUT
          echo "apply_status=$APPLY_EXIT_CODE" >> $GITHUB_OUTPUT

          # Exit with the same code as terraform apply
          exit $APPLY_EXIT_CODE

      - name: Create Apply Summary
        if: always()
        working-directory: ./terraform
        env:
          RESOURCES_ADDED: ${{ steps.apply.outputs.resources_added }}
          RESOURCES_CHANGED: ${{ steps.apply.outputs.resources_changed }}
          RESOURCES_DESTROYED: ${{ steps.apply.outputs.resources_destroyed }}
          APPLY_STATUS: ${{ steps.apply.outputs.apply_status }}
        run: |
          # Create a nice summary header
          echo "## Terraform Apply Results" >> $GITHUB_STEP_SUMMARY

          # Add status badge
          if [ "$APPLY_STATUS" == "0" ]; then
            echo "âœ… **Success**" >> $GITHUB_STEP_SUMMARY
          else
            echo "âŒ **Failed**" >> $GITHUB_STEP_SUMMARY
          fi

          # Add resource counts
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Resource Changes" >> $GITHUB_STEP_SUMMARY
          echo "| Added | Changed | Destroyed |" >> $GITHUB_STEP_SUMMARY
          echo "| ----- | ------- | --------- |" >> $GITHUB_STEP_SUMMARY
          echo "| $RESOURCES_ADDED | $RESOURCES_CHANGED | $RESOURCES_DESTROYED |" >> $GITHUB_STEP_SUMMARY

          # Add detailed output in a collapsible section
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "<details>" >> $GITHUB_STEP_SUMMARY
          echo "<summary>Detailed Apply Output</summary>" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo '```terraform' >> $GITHUB_STEP_SUMMARY

          # Check if apply_output.txt exists before trying to read it
          if [ -f "apply_output.txt" ]; then
            cat apply_output.txt >> $GITHUB_STEP_SUMMARY
          else
            echo "No detailed output available. The apply step may have failed to run." >> $GITHUB_STEP_SUMMARY
          fi
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "</details>" >> $GITHUB_STEP_SUMMARY

          # Add timestamp
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "*Completed at: $(date -u)*" >> $GITHUB_STEP_SUMMARY

      - name: Create GitHub Issue on Failure
        if: failure()
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // Create a simple issue with workflow link
            const issue = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: 'ðŸš¨ Terraform Apply Failed',
              body: `## Terraform Apply Failed

              **Workflow Run:** [View Workflow Run](https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})

              Please check the workflow logs for details.`,
              labels: ['terraform', 'infrastructure-failure']
            });

            console.log(`Created issue #${issue.data.number}: ${issue.data.html_url}`);

  cfn-deploy:
    name: 'CloudFormation Deploy'
    permissions:
      contents: read # for actions/checkout to fetch code
      id-token: write
      issues: write # needed to create issues
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        id: configure-aws-credentials
        uses: aws-actions/configure-aws-credentials@v4.1.0
        with:
          audience: sts.amazonaws.com
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: arn:aws:iam::${{ env.AWS_ACCOUNT_ID }}:role/${{ env.AWS_ROLE_TO_ASSUME }}

      - name: CloudFormation Prep
        id: cfn-prep
        working-directory: ./cloudformation
        run: |
          # Fetch AWS Account ID
          ACCOUNT_ID=$(aws sts get-caller-identity --query 'Account' --output text)
          # Configure Terraform backend
          REPO_OWNER=${GITHUB_REPOSITORY_OWNER}
          REPO_NAME=${GITHUB_REPOSITORY}

          # Get parameters
          echo "Get parameters.json from SSM parameter"
          aws ssm get-parameter \
            --name "/dcsummit25/cop401/cloudformation/json" \
            --query "Parameter.Value" \
            --output "text" \
            --region $AWS_REGION >> parameters.json

      - name: Validate CloudFormation Template
        id: cfn-validate
        working-directory: ./cloudformation
        run: |
          echo "::group::CloudFormation Validation"
          VALIDATION_OUTPUT=$(aws cloudformation validate-template --template-body file://template.yaml 2>&1)
          VALIDATION_EXIT_CODE=$?
          echo "$VALIDATION_OUTPUT"
          echo "::endgroup::"

          # Save validation status for later steps
          echo "validation_status=$VALIDATION_EXIT_CODE" >> $GITHUB_OUTPUT

          # Extract capabilities if validation succeeded
          if [ $VALIDATION_EXIT_CODE -eq 0 ]; then
            CAPABILITIES=$(echo "$VALIDATION_OUTPUT" | jq -r '.Capabilities[]' 2>/dev/null | tr '\n' ',' | sed 's/,$//')
            echo "capabilities=${CAPABILITIES:-NONE}" >> $GITHUB_OUTPUT
          fi

      - name: CloudFormation Deploy
        id: cfn-deploy
        uses: aws-actions/aws-cloudformation-github-deploy@v1.3.0
        with:
          name: ${{ env.STACK_NAME }}
          template: ./cloudformation/template.yaml
          no-fail-on-empty-changeset: "1"
          parameter-overrides: file:///${{ github.workspace }}/cloudformation/parameters.json

      - name: Get Stack Events
        id: cfn-events
        if: always()
        working-directory: ./cloudformation
        run: |
          # Get the most recent events (last 20)
          echo "::group::CloudFormation Stack Events"
          STACK_EVENTS=$(aws cloudformation describe-stack-events \
            --stack-name $STACK_NAME \
            --query "StackEvents[0:20]" \
            --output json 2>/dev/null || echo '[]')
          echo "$STACK_EVENTS" | jq
          echo "::endgroup::"

          # Save events to file for summary
          echo "$STACK_EVENTS" > stack_events.json

          # Extract stack status
          STACK_STATUS=$(aws cloudformation describe-stacks \
            --stack-name $STACK_NAME \
            --query "Stacks[0].StackStatus" \
            --output text 2>/dev/null || echo "UNKNOWN")
          echo "stack_status=$STACK_STATUS" >> $GITHUB_OUTPUT

          # Get resource counts
          RESOURCES_CREATED=$(echo "$STACK_EVENTS" | jq '[.[] | select(.ResourceStatus=="CREATE_COMPLETE")] | length')
          RESOURCES_UPDATED=$(echo "$STACK_EVENTS" | jq '[.[] | select(.ResourceStatus=="UPDATE_COMPLETE")] | length')
          RESOURCES_DELETED=$(echo "$STACK_EVENTS" | jq '[.[] | select(.ResourceStatus=="DELETE_COMPLETE")] | length')
          RESOURCES_FAILED=$(echo "$STACK_EVENTS" | jq '[.[] | select(.ResourceStatus | endswith("FAILED"))] | length')

          echo "resources_created=$RESOURCES_CREATED" >> $GITHUB_OUTPUT
          echo "resources_updated=$RESOURCES_UPDATED" >> $GITHUB_OUTPUT
          echo "resources_deleted=$RESOURCES_DELETED" >> $GITHUB_OUTPUT
          echo "resources_failed=$RESOURCES_FAILED" >> $GITHUB_OUTPUT

      - name: Create CloudFormation Summary
        if: always()
        working-directory: ./cloudformation
        env:
          VALIDATION_STATUS: ${{ steps.cfn-validate.outputs.validation_status }}
          CAPABILITIES: ${{ steps.cfn-validate.outputs.capabilities }}
          STACK_STATUS: ${{ steps.cfn-events.outputs.stack_status }}
          RESOURCES_CREATED: ${{ steps.cfn-events.outputs.resources_created }}
          RESOURCES_UPDATED: ${{ steps.cfn-events.outputs.resources_updated }}
          RESOURCES_DELETED: ${{ steps.cfn-events.outputs.resources_deleted }}
          RESOURCES_FAILED: ${{ steps.cfn-events.outputs.resources_failed }}
        run: |
          # Create a nice summary header
          echo "## CloudFormation Deployment Results" >> $GITHUB_STEP_SUMMARY

          # Add validation status
          echo "### Template Validation" >> $GITHUB_STEP_SUMMARY
          if [ "$VALIDATION_STATUS" == "0" ]; then
            echo "âœ… **Template Validation:** Passed" >> $GITHUB_STEP_SUMMARY
            if [ "$CAPABILITIES" != "NONE" ]; then
              echo "**Required Capabilities:** $CAPABILITIES" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "âŒ **Template Validation:** Failed" >> $GITHUB_STEP_SUMMARY
          fi

          # Add stack status
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Stack Status" >> $GITHUB_STEP_SUMMARY

          # Add status badge based on stack status
          case "$STACK_STATUS" in
            CREATE_COMPLETE|UPDATE_COMPLETE)
              echo "âœ… **Status:** $STACK_STATUS" >> $GITHUB_STEP_SUMMARY
              ;;
            CREATE_IN_PROGRESS|UPDATE_IN_PROGRESS|REVIEW_IN_PROGRESS)
              echo "â³ **Status:** $STACK_STATUS" >> $GITHUB_STEP_SUMMARY
              ;;
            ROLLBACK_*|DELETE_*|*FAILED)
              echo "âŒ **Status:** $STACK_STATUS" >> $GITHUB_STEP_SUMMARY
              ;;
            *)
              echo "â„¹ï¸ **Status:** $STACK_STATUS" >> $GITHUB_STEP_SUMMARY
              ;;
          esac

          # Add resource counts
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Resource Changes" >> $GITHUB_STEP_SUMMARY
          echo "| Created | Updated | Deleted | Failed |" >> $GITHUB_STEP_SUMMARY
          echo "| ------- | ------- | ------- | ------ |" >> $GITHUB_STEP_SUMMARY
          echo "| $RESOURCES_CREATED | $RESOURCES_UPDATED | $RESOURCES_DELETED | $RESOURCES_FAILED |" >> $GITHUB_STEP_SUMMARY

          # Add stack events in a collapsible section
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "<details>" >> $GITHUB_STEP_SUMMARY
          echo "<summary>Recent Stack Events</summary>" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Check if stack_events.json exists and has content
          if [ -f "stack_events.json" ] && [ -s "stack_events.json" ]; then
            echo "| Timestamp | Resource | Status | Reason |" >> $GITHUB_STEP_SUMMARY
            echo "| --------- | -------- | ------ | ------ |" >> $GITHUB_STEP_SUMMARY

            # Process the events and format as markdown table
            jq -r '.[] | "| \(.Timestamp) | \(.LogicalResourceId) | \(.ResourceStatus) | \(.ResourceStatusReason // "-") |"' stack_events.json >> $GITHUB_STEP_SUMMARY
          else
            echo "No stack events available." >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "</details>" >> $GITHUB_STEP_SUMMARY

          # Add stack outputs if available
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Stack Outputs" >> $GITHUB_STEP_SUMMARY

          # Get stack outputs with proper error handling
          STACK_OUTPUTS=$(aws cloudformation describe-stacks \
            --stack-name $STACK_NAME \
            --query "Stacks[0].Outputs" \
            --output json 2>/dev/null || echo 'null')

          # Check if outputs exist and are not null
          if [ "$STACK_OUTPUTS" != "null" ] && [ "$STACK_OUTPUTS" != "[]" ]; then
            echo "| Key | Value | Description |" >> $GITHUB_STEP_SUMMARY
            echo "| --- | ----- | ----------- |" >> $GITHUB_STEP_SUMMARY

            # Process the outputs and format as markdown table
            # Use a safer approach with jq that handles null values
            echo "$STACK_OUTPUTS" | jq -r '
              if . == null then
                "No outputs available."
              else
                .[] | "| \(.OutputKey) | \(.OutputValue) | \(.Description // "-") |"
              end
            ' >> $GITHUB_STEP_SUMMARY
          else
            echo "No stack outputs available." >> $GITHUB_STEP_SUMMARY
          fi

          # Add timestamp
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "*Completed at: $(date -u)*" >> $GITHUB_STEP_SUMMARY

      - name: Create GitHub Issue on Failure
        if: failure()
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // Create a simple issue with workflow link
            const issue = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: 'ðŸš¨ CloudFormation Deployment Failed',
              body: `## CloudFormation Deployment Failed

              **Stack Name:** ${{ env.STACK_NAME }}
              **Stack Status:** ${{ steps.cfn-events.outputs.stack_status || 'Unknown' }}
              **Workflow Run:** [View Workflow Run](https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})

              Please check the workflow logs for details.`,
              labels: ['cloudformation', 'infrastructure-failure']
            });

            console.log(`Created issue #${issue.data.number}: ${issue.data.html_url}`);